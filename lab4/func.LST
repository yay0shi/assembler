Turbo Assembler	 Version 5.0	    09-13-25 11:07:46	    Page 1
func.asm



      1					 ; Процедура Long2Str - преобразование 32-битного	числа  +
      2					 в строку
      3					 .386
      4	00000000			 .model	flat
      5					 ; функции, определяемые в этом	DLL
      6
      7					 public	Long2Str
      8	00000000			 .code
      9	00000000			 start:
     10	00000000  B0 01			 mov al, 1
     11	00000002  C2 000C		 ret 12
     12
     13	00000005			 Long2Str proc
     14	00000005  55			     push ebp
     15	00000006  8B EC			     mov ebp, esp			 ; Установка базового		    +
     16					 указателя
     17	00000008  51			     push ecx			 ; Сохраняем регистр CX	(будем	    +
     18					 использовать как счётчик	цифр)
     19
     20
     21
     22	00000009  8B 7D	0C		     mov edi, [ebp + 12]       ; DI = адрес строки
     23	0000000C  8B 45	08		     mov eax, [ebp + 8]	     ; Число для преобразования
     24
     25	0000000F  33 C9			     xor ecx, ecx	    ; ECX = 0 (счётчик цифр)
     26	00000011  BB 0000000A		     mov ebx, 10	    ; EBX = 10 (делитель)
     27
     28	00000016  83 F8	00		     cmp eax, 0
     29	00000019  79 0D	90 90 90 90	     jns skip_sign		 ; Если число >= 0, пропускаем	    +
     30					 установку минуса
     31
     32	0000001F  F7 D8			     neg eax		    ; Инвертируем число	(делаем его	    +
     33					 положительным)
     34	00000021  8B D0			     mov edx, eax	    ; Сохраняем модуль числа в EDX
     35	00000023  B0 2D			     mov al, '-'	    ; Записываем знак минус
     36	00000025  AA			     stosb		    ; Записываем знак в строку
     37	00000026  8B C2			     mov eax, edx	    ; Восстанавливаем число	(модуль)
     38
     39	00000028			 skip_sign:
     40	00000028  83 F8	00		     cmp eax, 0
     41	0000002B  75 0C	90 90 90 90	     jne next_digit	    ; Если EAX != 0, начинаем деление
     42
     43	00000031  B0 30			     mov al, '0'	    ; Если EAX == 0, просто пишем '0'
     44	00000033  AA			     stosb
     45	00000034  EB 16	90 90 90	     jmp finish			 ; Переход к завершению
     46
     47	00000039			 next_digit:
     48	00000039  33 D2			     xor edx, edx	    ; Очищаем EDX перед делением
     49	0000003B  F7 F3			     div ebx		    ; EAX / EBX	-> результат в EAX, остаток в	EDX
     50	0000003D  52			     push edx		    ; Сохраняем остаток	(цифру) в	стек
     51	0000003E  41			     inc ecx		    ; Увеличиваем счётчик цифр
     52	0000003F  83 F8	00		     cmp eax, 0
     53	00000042  75 F5			     jnz next_digit	    ; Повторяем, пока EAX != 0
     54
     55	00000044			 print_digits:
     56	00000044  5A			     pop edx		    ; Достаём цифру	из стека
     57	00000045  8A C2			     mov al, dl
Turbo Assembler	 Version 5.0	    09-13-25 11:07:46	    Page 2
func.asm



     58	00000047  04 30			     add al, '0'	    ; Преобразуем цифру	в ASCII
     59	00000049  AA			     stosb		    ; Записываем цифру в строку
     60	0000004A  E2 F8			     loop print_digits	    ; Повторяем для	всех цифр
     61
     62	0000004C			 finish:
     63	0000004C  B0 00			     mov al, 0		  ; Завершаем строку символом '$'
     64	0000004E  AA			     stosb
     65
     66	0000004F  59			     pop ecx				 ; Восстанавливаем CX
     67	00000050  5D			     pop ebp				 ; Восстанавливаем BP
     68	00000051  C2 0008		     ret 8				 ; Возвращаемся и убираем 8	    +
     69					 байт с стека
     70	00000054			 Long2Str endp
     71
     72					 end start
Turbo Assembler	 Version 5.0	    09-13-25 11:07:46	    Page 3
Symbol Table




Symbol Name			  Type	 Value

??date				  Text	 "09-13-25"
??filename			  Text	 "func	  "
??time				  Text	 "11:07:46"
??version			  Number 0500
@32Bit				  Text	 1
@CodeSize			  Text	 0
@Cpu				  Text	 0F0FH
@DataSize			  Text	 0
@FileName			  Text	 func
@Interface			  Text	 000h
@Model				  Text	 1
@WordSize			  Text	 4
@code				  Text	 FLAT
@curseg				  Text	 _TEXT
@data				  Text	 FLAT
@stack				  Text	 FLAT
Long2Str			  Near32 FLAT:0005
finish				  Near32 FLAT:004C
next_digit			  Near32 FLAT:0039
print_digits			  Near32 FLAT:0044
skip_sign			  Near32 FLAT:0028
start				  Near32 FLAT:0000

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  32  0000 Dword  Public  DATA
FLAT				  Group
_TEXT				  32  0054 Dword  Public  CODE
